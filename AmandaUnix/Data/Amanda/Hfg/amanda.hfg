.title Amanda V2.05

..introduction
....amanda(101)
....initialisation(102)
....restrictions(107)
....default implementation(103)
....Windows implementation
......files(104)
......remote objects(106)
......amanda graphics(108)
......graphAnimate(544)
..language
....constructs
......expressions(301)
......functions(302)
......patterns(303)
......where clauses(304)
......lambda abstractions(305)
......listcomprehensions(306)
......operators(307)
....types
......basic types(311)
......list types(312)
......tuple types(313)
......algebraic types(314)
......record types(315)
......type synonyms(316)
......abstract types(317)
......generic functions(318)
......type checking(319)
....preprocessing
......comments(321)
......#import(322)
......#synonym(323)
......#operator(324)
..predefined functions
....environment functions
......exit(401)
......info(402)
......load(403)
......reload(404)
......time(405)
......debug(406)
......error(407)
....predefined operators
...... ^(411)
...... *(412)
...... /(413)
...... //(414)
...... %(415)
...... +(416)
...... -(417)
...... =(418)
...... ~=(419)
...... <(420)
...... <=(421)
...... >(422)
...... >=(423)
...... .(424)
...... :(425)
...... !(426)
...... ++(427)
...... --(428)
...... /\(429)
...... \/(430)
...... #(431)
...... ~(432)
...... &(433)
....predefined constants
......True(441)
......False(442)
......pi(443)
......Nil(444)
....library functions
......rep(451)
......cjustify(452)
......ljustify(453)
......rjustify(454)
......lines(455)
......words(456)
......isspace(457)
......isupper(458)
......islower(459)
......toupper(460)
......tolower(461)
......nodup(462)
......unlines(463)
......sort(464)
......transpose(465)
......mergeSort(466)
......merge(467)
......zipwith(468)
....builtin functions
......and(471)
......abs(472)
......concat(473)
......drop(474)
......dropwhile(475)
......empty(476)
......filter(477)
......foldl(478)
......foldl1(479)
......foldr(480)
......foldr1(481)
......fst(482)
......if(483)
......iterate(484)
......hd(485)
......map(486)
......max(487)
......max2(488)
......member(489)
......min(490)
......min2(491)
......nat(492)
......nats(493)
......neg(494)
......or(495)
......prod(496)
......reverse(497)
......scan(498)
......seq(499)
......snd(500)
......split(501)
......splitwhile(502)
......sum(503)
......strict(504)
......take(505)
......takewhile(506)
......timedate(507)
......tl(508)
......until(509)
......zip(510)
......zip2(511)
......zip3(512)
....numerical functions
......round(521)
......trunc(522)
......decode(523)
......code(524)
......random(525)
......cos(526)
......sin(527)
......exp(528)
......log(529)
......sqrt(530)
......atan(531)
......itoa(532)
......atoi(533)
......ftoa(534)
......atof(535)
....file functions
......fread(541)
......fwrite(542)
......fappend(543)
.page 101 amanda

Amanda is a functional programming language developed by Dick Bruin
for recreational purposes (solving mathematical puzzles).

Anyone can freely use the Amanda interpreter to develop his/her own
functional programs. Amanda has been tested on a large set of programs
and seems to function unproblematic. But please note that the author
cannot be blamed for any unexpected behaviour.


Amanda is based on the notation used in the book "Introduction to Functional Programming"
written by Richard Bird and Philip Wadler and published by Prentice Hall.


Amanda is implemented using the ideas described in the book
"The implementation of functional programming languages" written by
Simon Peyton Jones and published by Prentice Hall.

.page 102 initialisation

On startup Amanda loads the file amanda.ini which is an Amanda script file
containing definitions of a few library functions and the startup settings.

NB: make sure Amanda can locate amanda.ini (in the same directory as the
executable image of the interpreter)


The following settings can be defined:
.literal
MemorySize        (the number of available cells)
WinFontName       (the name of the font used by a graphical environment)
WinFontSize       (the size of this font)
.endliteral
Default version of amanda.ini:
.literal
|| amanda.ini, Dick Bruin

|| MemorySize  = 100000
|| WinFontName = "Courier New"
|| WinFontSize = 10
|| ConPrompt   = "> "

rep:: * -> num -> [*]

rep x n = [x | k <- [1..n]]


cjustify:: num -> [char] -> [char]

cjustify n str = rep ' ' (s / 2) ++ str ++ rep ' ' (s - s / 2)
where
  s = n - # str


ljustify:: num -> [char] -> [char]

ljustify n str = str ++ rep ' ' (n - # str)


rjustify:: num -> [char] -> [char]

rjustify n str = rep ' ' (n - # str) ++ str


lines:: [char] -> [[char]]

lines [] = []
lines string = first : lines (drop 1 rest)
where
  (first, rest) = splitwhile ('\n' ~=) string


unlines:: [[char]] -> [char]

unlines lines = [ch | line <- lines; ch <- line ++ "\n"]


words:: [char] -> [[char]]

words [] = []
words string = first : words (dropwhile isspace rest)
where
  (first, rest) = (splitwhile (~ . isspace) . dropwhile isspace) string


isspace:: char -> bool

isspace ch = ch = ' ' \/ ch = '\n' \/ ch = '\t'


isupper:: char -> bool

isupper ch = ch >= 'A' /\ ch <= 'Z'


islower:: char -> bool

islower ch = ch >= 'a' /\ ch <= 'z'


toupper:: char -> char

toupper ch = decode (code ch + code 'A' - code 'a') ,if islower ch
           = ch                                     ,otherwise


tolower:: char -> char

tolower ch = decode (code ch + code 'a' - code 'A') ,if isupper ch
           = ch                                     ,otherwise


nodup:: [*] -> [*]

nodup (h:t) = h : nodup (filter (h ~=) t)
nodup l     = l


sort:: [*] -> [*]

sort (h:t) = sort [u | u <- t; u < h] ++ [h] ++ sort [u | u <- t; u >= h]
sort l     = []


transpose:: [[*]] -> [[*]]

transpose x = []                              ,if empty x \/ or(map empty x)
            = map hd x : transpose (map tl x) ,otherwise


mergeSort:: [*] -> [*]

mergeSort list
= list ,if half < 1
= merge (mergeSort(take half list)) (mergeSort(drop half list))
where
  half = (# list) / 2


merge:: [*] -> [*] -> [*]

merge (l1=h1:t1) (l2=h2:t2) = h1 : merge t1 l2 ,if h1 < h2
                            = h2 : merge l1 t2 ,otherwise
merge [] l2                 = l2
merge l1 []                 = l1


zipwith :: (* -> ** -> ***) -> [*] -> [**] -> [***]

zipwith (+) xs ys = [x + y | x, y <- xs, ys]


#synonym div /
#synonym mod %

|| graphics protocol

graphics ::= GraphText num (num, num) [char] 
           | GraphPolyLine num [(num, num)] 
           | GraphPolygon num [(num, num)] 
           | GraphRectangle num (num, num) (num, num)
           | GraphEllipse num (num, num) (num, num)
           | GraphDisc num (num, num) (num, num)

graphicsout:: [graphics] -> [[char]]

graphicsout = concat.map graphicsToString

graphicsToString (GraphText color (x, y) text) = ["GraphText", itoa color] ++ coordsToString (x, y) ++ [text]
graphicsToString (GraphPolyLine color ps) = ["GraphPolyLine", itoa color] ++ concat[coordsToString (x, y) | (x, y) <- ps] ++ ["End"]
graphicsToString (GraphPolygon color ps) = ["GraphPolygon", itoa color] ++ concat[coordsToString (x, y) | (x, y) <- ps] ++ ["End"]
graphicsToString (GraphRectangle color (x1, y1) (x2, y2)) = ["GraphRectangle", itoa color] ++ coordsToString (x1, y1) ++ coordsToString (x2, y2)
graphicsToString (GraphEllipse color (x1, y1) (x2, y2)) = ["GraphEllipse", itoa color] ++ coordsToString (x1, y1) ++ coordsToString (x2, y2)
graphicsToString (GraphDisc color (x1, y1) (x2, y2)) = ["GraphDisc", itoa color] ++ coordsToString (x1, y1) ++ coordsToString (x2, y2)

coordsToString (x, y) = map ftoa [x, y]
.endliteral

.page 107 restrictions

Amanda has been designed with a PC-DOS environment in mind. The awkward
memory structure of PC-DOS still leaves traces in Amanda.


Some memory related restrictions:

- a global function definition should not be larger than 4000 cells

- the internal stack is rather small

- patterns can only be 32 levels deep


The implementation of pattern matching and selection might lead to
memory leaks as the following example shows:
.literal
primes = sieve [2..]
sieve (x:xs) = x : sieve[y | y <- xs; y % x ~= 0]
.endliteral
This example will very quickly go out of memory, because in order to access
x the list comprehension keeps a reference to the whole list (x:xs).

To avoid this it should be changed to:
.literal
primes = sieve [2..]
sieve l = x : sieve[y | y <- xs; y % x ~= 0]
where
  x = hd l
  xs = tl l
.endliteral
Or to:
.literal
primes = sieve [2..]
sieve (x:xs) = s x xs
s x xs = x : sieve[y | y <- xs; y % x ~= 0]
.endliteral
Another cause of excessive memory usage might be lazy evaluation itself.
As an example consider a function that calculates the frequencies of characters
in a string:
.literal
freq string = foldl insert [0 | k <- [0..255]] string
where
  insert table c = table1 ++ (f+1):table2
  where
    (table1, f:table2) = split (code c - 1) table
.endliteral
This will usually go out of memory very quickly, because insert operations
are done lazily and large closures of work to be done are kept.

To avoid this the whole table should be evaluated every time.
.literal
freq string = foldl insert [0 | k <- [0..255]] string
where
  insert table c = seq (sum result) result
  where
    (table1, f:table2) = split (code c - 1) table
    result = table1 ++ (f+1):table2
.endliteral
The function seq always evaluates its first argument and sum will traverse
the whole list.

.page 103 default implementation

Amanda is written in ANSI-C and can be ported easily to many platforms.


The default implementation acts like an advanced calculator. It displays
a commandline on which an expression can be entered. The result of the
evaluation (reduction) of the expression is displayed. By appending :: after
an expression not its value but its type will be displayed.


Examples:
.literal
Amanda> 1 + 2
3
Amanda> 1 + 2 ::
num
Amanda> fac 3 where fac 0 = 1; fac n = n * fac (n-1)
6
Amanda> load "a:\test.ama"
Amanda> info
....
Amanda> exit
.endliteral

.page 104 files

The Windows implementation contains all the basic functionality.


The Windows implementation consists of the files:
.literal
- ama.exe               console application
- amanda.exe            windows application
- amadll.dll            dll with amanda kernel
- amanda.ini            initialisation file
- amanda.hlp            help file
- amanda.cnt            help contents file
.endliteral

See also:
.link 102 initialisation

.page 106 remote objects

The dynamic link library amadll.dll can be used from other Windows programs to
create and use remote objects.


Remote objects are defined in Amanda by specifying the function object like this:
.literal
primes = sieve [2..] 

sieve l = x : sieve [y | y <- xs; y % x ~= 0]
where
  x = hd l
  xs = tl l

object "primes" = ([], call)
where
  call "Start" _ _ = (primes, [])
  call "Next" _ (p:ps) = (ps, [itoa p])
  call "Between" [low, high] ps = (ps, (map itoa . takewhile (< hi) . dropwhile (<= lo)) ps)
  where
    lo = atoi low
    hi = atoi high
.endliteral

This declares an object called "primes" with methods "Start", "Next" and "Between".

The object has a state which is initially [] and which is manipulated by the function called "call".
This function defines the response of the object to the methods "Start", "Next" and "Between".

The method "Start" initialises the state and returns no answers.

The method "Next" ignores possible parameters and changes the state from p:ps to ps and returns one 
answer: itoa p.

The method "Between" has two parameters, does not change the state and returns all the
prime numbers which are in the state and are between the lo and hi values.


The corresponding Delphi object might be:
.literal
uses AmaDllUnit;

type
  TPrimes = class(TAmaObject)
  public
    constructor Create;
    procedure Start;
    function Next: Integer;
    function CountBetween(low, high: Integer): Integer;
    // CountBetween is easier than Between itself
  end;

constructor TPrimes.Create;
begin
  inherited Create('primes');
end;

procedure TPrimes.Start;
begin
  Call('Start');
end;

function TPrimes.Next: Integer;
var
  s: String;
begin
  Call('Next');
  if not Get(s) then raise Exception.Create('First press Start');
  result := StrToInt(s)
end;

function CountBetween(low, high: Integer): Integer;
var
  s: String;
begin
  Put(IntToStr(low));
  Put(IntToStr(high));
  Call('Between');
  result := 0;
  while Get(s) do result := result + 1;
end;
.endliteral

Here TAmaObject is defined in the unit AmaDllUnit and has Create, Put, Call and Get methods.
.literal
Create   makes a connection to an Amanda remote object
Put      defines a parameter to a method call
Call     calls a method
Get      retrieves a return value
.endliteral

Names of objects, names of methods, parameters and return values are all strings, which makes
things both flexible and error prone (no explicit type checking in Delphi and in Amanda).


The function object has the following type:
.literal
object :: [char] -> (*, [char] -> [[char]] -> * -> (*, [[char]]))

with intended meaning:
object objectname = (state, callfunction)
callfunction methodname listOfParameters state = (state, listOfReturnValues)
.endliteral

For more information consult the file AmaDllUnit.pas:
.literal
unit AmaDllUnit;
(*
  Dick Bruin, 25/10/1998

  interface to Amadll.dll
  assumptions: Amanda.ini and Amadll.dll are in the same directory as the executable

  Example:

  Amanda part:
  object "main" = ([], call)
  where
    call "start" _    _  = (primes, ["YES"])
    call "next"  [sn] ps = (drop n ps, (map itoa . take n) ps) where n = atoi sn

  primes = sieve [2..]
  sieve l = x : sieve [y | y <- xs; y % x ~= 0]
  where
    x = hd l
    xs = tl l

  the object "main" has a state consisting of prime numbers (initially [])
  and can respond to calls to "start" and "next"
  the remote call "start" changes the state and returns the answer "YES"
  the remote call "next" changes the state and returns some prime numbers

  Delphi part:
  AmaInit('...');
  main = TAmaObject.Create('main');
  if main.Ok then
  begin
    main.Call('start');

    main.Put(IntToStr(10));
    main.Call('next');
    Edit1.Text := '';
    while main.Get(s) do Edit1.Text := Edit1.Text + s + ' ';
  end;
  main.Free;
*)

interface

function AmaInit(const filename: String): Boolean;

type
  TAmaObject = class(TObject)
  public
    constructor Create(const name: String);
    destructor Destroy; override;
    function Ok: Boolean;
    procedure Put(const param: String);
    function Call(const fun: String): Boolean;
    function Get(var res: String): Boolean;
  private
    handle: Integer;
  end;

(*
  Explanation:
  
  AmaInit               initialises Amadll and loads the given Amanda file
  TAmaObject.Create     tries to connect to a remote object with the given name
  TAmaObject.Destroy    releases a remote object
  TAmaObject.Ok         indicates if a connection to a remote object is made
  TAmaObject.Put        sets a parameter for a remote procedure call
  TAmaObject.Call       performs a remote procedure call
  TAmaObject.Get        retrieves a result string from a remote procedure call
*)

function AmaInitialise(const filename: String; ws: Pointer): Boolean;

implementation
uses SysUtils;

function  AmaInitRemote(path, filename: PChar; ws, cio: Pointer): Integer; stdcall; external 'amadll.dll';
function  AmaCreateRemote(s: PChar): Integer;                              stdcall; external 'amadll.dll';
procedure AmaDropRemote(handle: Integer);                                  stdcall; external 'amadll.dll';
procedure AmaPutRemote(handle: Integer; s: PChar);                         stdcall; external 'amadll.dll';
function  AmaCallRemote(handle: Integer; s: PChar): Integer;               stdcall; external 'amadll.dll';
function  AmaGetRemote(handle: Integer; s: PChar; size: Integer): Integer; stdcall; external 'amadll.dll';

var
  buffer: array[0..2047] of Char;

function AmaInit(const filename: String): Boolean;
begin
  result := AmaInitRemote(PChar(ParamStr(0)), PChar(filename), Nil, Nil) <> 0;
end;

constructor TAmaObject.Create(const name: String);
begin
  inherited Create;
  handle := AmaCreateRemote(PChar(name));
end;

destructor TAmaObject.Destroy;
begin
  AmaDropRemote(handle);
  inherited Destroy;
end;

function TAmaObject.Ok: Boolean;
begin
  result := handle >= 0;
end;

procedure TAmaObject.Put(const param: String);
begin
  AmaPutRemote(handle, PChar(param));
end;

function TAmaObject.Call(const fun: String): Boolean;
begin
  result := AmaCallRemote(handle, PChar(fun)) <> 0;
end;

function TAmaObject.Get(var res: String): Boolean;
begin
  result := AmaGetRemote(handle, buffer, sizeof(buffer)) <> 0;
  if result then res := buffer;
end;

function AmaInitialise(const filename: String; ws: Pointer): Boolean;
begin
  result := AmaInitRemote(PChar(ParamStr(0)), PChar(filename), ws, Nil) <> 0;
end;

end.
.endliteral


.page 108 amanda graphics

AmaGr is an application to do graphical interaction with Amanda

usage: AmaGr <Amanda file>


from Amanda issue the command: amaGraphics


it loads an Amanda file which should contain an interaction object

user events are forwarded to this object, which result in a change of
the state of the object and a list of graphical commands which is
displayed in a paintbox


example of the AmaObject:
.literal
object "AmaGraphics" = (beginSpel 5, call)
where
  call "DefSystem" _ state     = (state, ["timer", "0", "showParameters", "False"])
  call "DefParameters" _ state = (state, ["Grootte", "4|5|6|7"])
  call "DefActions" _ state    = (state, ["Mens", "Computer", "Vrij", "Terug"])

  call "Action" ["Mens"] spel     = repaint (nieuwSpel Groen spel)
  call "Action" ["Computer"] spel = repaint (nieuwSpel Rood spel)
  call "Action" ["Vrij"] spel     = repaint (nieuwSpel Geen spel)
  call "Action" ["Terug"] spel    = repaint (terugSpel spel)

  call "Parameters" [g] spel = repaint (beginSpel (atoi g))

  call "MouseDown" [x1, y1, x2, y2] spel = zetSpel (atof x1, atof y1) spel

  call "Repaint" [] spel = repaint spel
  call _ _ spel = (spel, [])

  repaint spel = (spel, graphicsout(tekenSpel spel))
.endliteral


The interaction object must be called AmaGraphics.

The call DefSystem should respond with values for timer and showParameters.
If the timer value is bigger than zero a timer generates calls like: call "Timer" []
The value of showParameters should be False or True.


The call DefParameters initialises the parameters window and consists of item, value pairs.
Multiple value possibilities should be separated by bars.
The "set" button of the parameters window generates a call like: call "Parameters" ["4"]
(the order of the parameters is obeyed)


The call DefActions initialises the menu items.
A menu item generates a call like: call "Action" ["Mens"]


Dragging generates a call like: call "MouseDown" [x1, y1, x2, y2]
where (x1, y1) is the position of the mouseDown and (x2, y2) the position of the mouseUp

During the dragging calls are generated like: call "MouseDrag" [x1, y1, x2, y2]
They are similar to the MouseDown calls except drawing is in XOR-mode


Painting of the paintbox generates a call of the AmaObject like: call "Repaint" []

.page 544 graphAnimate

graphAnimate :: num -> num -> [graphics] -> bool


graphAnimate width height graphicsCommands opens a graphical window
in which the graphical commands are displayed.

GraphWait msecs causes a pause of the given amount of millisecs, which makes
animation possible.
.page 301 expressions

Amanda is about reducing expressions. So expressions form the heart of Amanda.


Expressions can be numbers, characters, strings, booleans, constructors, tuples, lists, records,
function applications, operator applications, operator sections and list comprehensions.


Examples:
.literal
12
'a'
"Hello world"
True
False
GraphPolyLine 1 [(-1, -1), (-1, 1), (0, 0)]
()
(-13, "Bye world", 'a')
[]
[1, 2, 3, 5]
[1..10]
{ x = 0, y = 0, z = 0 }
fac 3
12 + 3 * 8
(2 *)
[x | x <- [1..100]; x % 2 = 0]
.endliteral
Special characters are denoted as in the C-language like \n, \b, \t, \r, \a.

\e denotes the escape character.

\xFF denotes a character using hexadecimal ascii notation.

.page 302 functions

Functions are defined using equations in the style of Bird and Wadler.


Example:
.literal
fac 0 = 1
fac n = n * fac (n-1)
.endliteral
Example:
.literal
fac n = 1             ,if n = 0
      = n * fac (n-1) ,otherwise
.endliteral
Note: in situations of multiple definitions for one left hand side the
defining symbols '=' should be written exactly under each other.


The left hand side may contain patterns.

But important restrictions on the use of patterns are:

- in a single definition all pattern variables must have different names

- patterns of the form (n+1) are not allowed

- multiple definitions of the same function must have different patterns


Wrong definitions are:


Counterexample:
.literal
equal x x = True
equal x y = False
.endliteral
This is wrong because the first definition has
two pattern variables with the same name.


Counterexample:
.literal
equal x y = True  ,if x = y
equal x y = False ,if x ~= y
.endliteral
This is wrong because the patterns of the definitions
coincide.

It is accepted by the interpreter but will never use
the second definition.

The correct way to define this function is:
.literal
equal x y = True  ,if x = y
          = False ,if x ~= y
.endliteral
A function can have private definitions in a where clause.


Example:
.literal
mergeSort list
= list ,if half < 1
= merge (mergeSort(take half list)) (mergeSort(drop half list))
where
  half = (# list) / 2
.endliteral

See also:
.link 303 patterns
.link 304 where clauses

.page 303 patterns

Patterns occur in the left hand side of a function definition, in the
generators of listcomprehensions and in the left hand side of local definitions.

Patterns play two distinct roles: they define selectors for parts of an expression
and they constrain the type of an expression (see
.link 318 generic functions
)


Patterns may contain:
.literal
  constants
  basic types (num, bool, char)
  lists
  tuples
  constructors of an algebraic type
  records
  aliases
  wildcards (the underscore _)
.endliteral
An alias is a name of a part of a pattern as the next example shows:
.literal
merge (l1 = h1:t1) (l2 = h2:t2) = h1 : merge t1 l2 ,if h1 < h2
                                = h2 : merge l1 t2 ,otherwise
.endliteral
Here l1 is an alias for h1:t1 and can be used on the right hand side.


The wildcard _ may be used to indicate a don't care pattern.
Wildcards may occur more than once in the same pattern expression.

.page 304 where clauses

A where clause contains private local definitions of a function.

The layout rule for where clauses is:


Layout rule 1:

The keyword 'where' can be put right under or to the right of the symbol '='
of the function definition and the definitions in the where clause
are put to the right of the symbol '='.


Example:
.literal
  fac n
= p [1..n]
   where
  p = prod
.endliteral
Layout rule 2:

The keyword 'where' can be placed right under or to the right of
the function name and the definitions in the where clause are put to the
right (so not under) the keyword 'where'.


Example:
.literal
fac n = p [1..n]
where
  p = prod
.endliteral

.page 305 lambda abstractions

Lambda abstraction is an alternative way to define a function.


Its basic form is:

<pattern> -> <expression based on the pattern>


In order to define a function with more than 1 argument this construction
should be used repeatedly:

<pattern1> -> <pattern2> -> ... -> <patternN> -> <expression>


Alternatives are separated by |


Examples:
.literal
map (n -> n+1) [1..]
foldl (n -> m -> n // m) 1 [1..10]

minmax = foldl ((min, max) -> x -> (min2 min x, max2 max x)) (infinite, -infinite)
where
  infinite = 100000

fac = 0 -> 1 | n -> n * fac (n-1)

divide = x -> (0 -> error "division by zero" | y -> x / y)
.endliteral
Of course this is a clumsy way to define the divide function.

Better is:
.literal
divide = x -> 0 -> error "division by zero" | x -> y -> x / y
.endliteral
Much better is:
.literal
divide x 0 = error "division by zero"
divide x y = x / y

weird = x -> x -> x
.endliteral
From the last definition it is obvious that patterns in a lambda abstraction may
be the same.

It is renamed like:
.literal
weird = var1 -> var2 -> var2
.endliteral

.page 306 listcomprehensions

Listcomprehensions extend Bird and Wadler syntax.


Besides generators and conditions a listcomprehension may introduce
an abbreviation using the assignment operator (:=).

Another feature is the implicit zip notation.


A generator like:

  x, y <- [1..100], [1..]

is the equivalent of

  (x, y) <- zip2 [1..100] [1..]


Likewise

  a, b, c := 1, 2, 3

denotes

  (a, b, c) <- zip3 [1] [2] [3]


Example:
.literal
pythagoras = [ (x, y, z) |
                 z <- [1..];
                 y <- [1..z];
                 x <- [1..y];
                 x^2 + y^2 = z^2
             ]

evenQuadrats = [ x * x | x <- [0..]; x % 2 = 0 ]

evenQuadrats = [ x * x | x <- [0,2..] ]

evenQuadrats = [ y | x <- [0..]; y := x * x; y % 2 = 0 ]

evenQuadrats = [ y | x <- [0,2..]; y := x * x]

queens 0 = [[]]
queens m = [ p ++ [n] |
              positions := [1..8];
              p <- queens (m-1);
              n <- positions;
              [True | i, j <- positions, p; j=n \/ i+j=m+n \/ i-j=m-n] = []
           ]
.endliteral

Also multiple results may be generated like in:

[x, x+y, x+2*y | x <- [1..10]; y <- [1..x]]

which is the equivalent of:

[z | x <- [1..10]; y <- [1..x]; z <- [x, x+y, x+2*y]]

.page 307 operators

Infix operators can be defined as in the following examples:


Example:
.literal
|| a complex number is represented by a pair
complex == (num, num)

+++ :: complex->complex->complex
( (x1,y1) +++ (x2, y2) ) = (x1+x2, y1+y2)
.endliteral
The name of an operator consists of punctuation characters
like +, -, *, /, #, etc...

The left-hand side of the definition must be enclosed in parentheses.


Infix operators may be used as functions using prefix notation.


Example:
.literal
addComplex :: complex->complex->complex
addComplex c1 c2 = +++ c1 c2    || equivalent to  c1 +++ c2
.endliteral
Functions with at least two arguments may be used as operators
using a $ as prefix.


Example:
.literal
c1 $addComplex c2
.endliteral
Sections can be defined just like in Bird and Wadler (be careful to
surround them with parentheses).


Examples:
.literal
positiveNumbers :: [num] -> [num]
negativeNumbers :: [num] -> [num]
positiveNumbers = filter (0 <)
negativeNumbers = filter (< 0)
.endliteral
See also:
.link 324 #operator

.page 311 basic types

The basic types are:
.literal
num     || both integer and real
bool    || with only values True, False
char    || ascii set
.endliteral

.page 312 list types

List types are denoted by:

[ <typeName> ]

.page 313 tuple types

Tuple types are denoted by:

()

( <typeName>, <typeName>, ... <typeName> )


The first form defines an empty tuple type. The only possible value of
this type is () the empty tuple.

Of course (for syntactical reasons) unary tuples are not available.

.page 314 algebraic types

Concrete algebraic types can be defined like:


Example:

numTree ::= Leaf num | Branch numTree numTree


Example:

tree (*) ::= Leaf (*) | Branch (tree (*)) (tree (*))


With (*) a polymorphic typevariable is denoted.

The parentheses around (*) are not strictly necessary,
so one may write:

tree * ::= Leaf * | Branch (tree *) (tree *)


NB: the ordering of the elements of a concrete type is undefined, though
equality tests are perfectly valid.

.page 315 record types

Record types are defined as in the following example:


vector * ::= { x :: *, y :: *, z :: * }


For every field a selector function is defined like:

x { x=xr, y=yr, z=zr } = xr


The drawback of this construction is that all field names of all record types
must be different.


A constant record can be denoted like:

{ x = 1, y = 2, z = 3 }

{ y = 100, z = 20 }


From the last example it is obvious that partial records can be defined. Of course
the omitted fields should never be accessed.

Empty records are not available (what could be their use ?)

Partial records are useful for pattern matching and for updates.


Functions on records can be defined using the field access functions:

innerproduct r1 r2 = x r1 * x r2 + y r1 * y r2 + z r1 * z r2


or using patterns:

innerproduct { x=x1, y=y1, z=z1 } { x=x2, y=y2, z=z2 } = x1*x2 + y1*y2 + z1*z2


The operator & is used to update a record with information from another record:
.literal
clearx r = r & { x = 0 }
doublex (r = { x = xr }) = r & { x = 2 * xr }
.endliteral
In the function double the argument is called r and its field x is called xr and
the result is r with its field x changed to twice its original value. The result
of course is a copy of the record r with a new value for field x.

.page 316 type synonyms

Typesynonyms are denoted like:


string == [char]


complex == (num, num)


point * == (*, *)

.page 317 abstract types

Abstract types are denoted like:
.literal
abstype stack *
with
  push    :: * -> stack * -> stack *
  pop     :: stack * -> stack *
  top     :: stack * -> *
  isEmpty :: stack * -> bool
  create  :: stack *

stack * == [*]

push x s  = x:s
pop (x:s) = s
top (x:s) = x
isEmpty s = s = []
create    = []
.endliteral
An abstract type hides the implementation. This means that only the functions
belonging to the abstract type may use the implementation details.

In the example push uses the list constructor, which is correct because stack *
is defined as a list and push belongs to the abstract type.

But functions outside the abstract type may only use push to add something on a stack.


NB: an abstract type must be a synonym of another type.

.page 318 generic functions

Like abstract types generic functions are a feature of the typechecker.


Usually polymorphism means structural polymorphism like in:
.literal
hd :: [*] -> *
hd (x:_) = x
.endliteral
The polymorphism of the function ?= (equality test) is of a different kind
because it is defined differently for different types. Although in all cases
the type conforms with its generic type.


We could define ?= for some cases like:
.literal
generic ?= :: * -> * -> bool

([]      ?= []     ) = True
(x:xs    ?= y:ys   ) = x ?= y /\ xs ?= ys
(True    ?= True   ) = True
(False   ?= False  ) = True
((x1,y1) ?= (x2,y2)) = x1 ?= x2 /\ y1 ?= y2
...
(_ ?= _) = False   || default unequal
.endliteral
The keyword generic indicates that the function could be defined for
different cases all conforming to the specified generic type scheme.


Example:
.literal
generic print :: * -> [char]

print (x = num)  = ftoa x
print True       = "True"
print False      = "False"
print (c = char) = [c]
print []         = "[]"
print (x:xs)     = "[" ++ print x ++ concat[", " ++ print y | y <- xs] ++ "]"
print (x, y)     = "(" ++ print x ++ ", " ++ print y ++ ")"
...
.endliteral
The pattern (x = num) means that x is an alias for an element of type num.
Only the basic types num, bool and char may be used as patterns.


NB: because the type checking regime for generic functions is weaker than for
normal functions, generic functions should be used with care.


See
.link 319 type checking
for a more elaborate explication of the type inference process

.page 319 type checking

The task of the type checker is to ensure that on run time "things can't go wrong".
Of course infinite loops, division by zero or failing patterns are in general not
detectable on compile time. But checking that a function is called with the
correct number and type of arguments is feasible.


The type checker generally does the following things:

- it substitutes all occurrences of type synonyms

- it ensures that the definitions of abstract types are only visible for
the functions belonging to it

- it finds and checks all the types of normal functions

- it checks the types of generic functions


Example:
.literal
f [] = 0
f (x:xs) = add x (f xs)

add x y = x + y
.endliteral
The type inference goes like this.


Firstly the most general assumptions on the types are made:

f   :: *

add :: *


From the first clause of f is deduced:

f :: [*] -> num

From the second clause of f is deduced (using the known types of f and add):

f :: [*] -> **

The function should comply to both types so the types are "unified" giving:

f :: [*] -> num


The same thing is done for the function add giving:

add :: num -> num -> num


Because the type of add has changed the second clause of the function f should be
considered again giving:

f :: [num] -> num


This process is repeated until all types are stable.

If the programmer has provided types for functions these are taken as a starting point.
In that way the programmer can restrict the type of a function.


The repeated approximation of the types makes polymorphism possible.
So a strange function like the following is correctly typed:
.literal
f x 0 = x
f x n = x ,if f 1 0 = 1 \/ f [1] 1 = [1]
.endliteral
For local definitions in a where clause a more rigid scheme is used. All
occurrences of such a definition share the same type. This excludes polymorphism,
but speeds up the type inference process and rarely gives problems because
polymorphic functions are usually shared by many functions and are thus global.


The types of generic functions are provided by the programmer so at first
sight the type checker only needs to check if all the clauses conform to
this given type.


But examples like the following show that this is not desirable:
.literal
generic f :: num -> *

f 0 = 'a'
f 1 = 1

generic g :: [*] -> (*, **)

g [1] = (0, 0)
g []  = ('a', 'a')
.endliteral
Expressions like [f 0, f 1] and [g [], g [1]] are now going wrong.


The problem is caused by the occurrence of a new type variable in the result.
So this is not allowed.

A similar thing may happen at run time if the patterns of function clauses
are not tight enough.


Example:
.literal
generic print :: * -> [char]

print [] = "[]"
print (x:xs) = "[" ++ print x ++ concat[", " ++ print x | x <- xs] ++ "]"
print n = ftoa n
print c = [c]
.endliteral
The clauses have the following types:
.literal
[*] -> [char]
[*] -> [char]
num -> [char]
*   -> [*]          (becomes char -> [char] after unification)
.endliteral
They can all be unified with the generic type scheme.

But the call (print 'a') goes wrong because the third clause will be used.


The problem is caused by the fact that at run time the input determines which
clause is activated but the type is also determined by the output.
The pattern of the third clause is too weak to ensure that only numbers are plugged in.
Likewise the pattern of the fourth clause is too weak.


For a clause of a generic function the type checker at first deduces a type
based on the given input patterns and unifies this with the generic type scheme
giving the actual type. Then the type of the result is found and unified with it.
If new constraints are found the clause is rejected.


For the third clause (print n = ftoa n) the actual type based on the input is:

* -> [char]

but the result leads to the type

num -> [char]

So the result imposes extra constraints and the clause is rejected.


The programmer should change the clause to:

print (n = num) = ftoa n

.page 321 comments

After || the rest of a line is treated as a comment.

Also a C-style comment is supported.


Example:
.literal
|| this is comment

/*
   this is /* a comment */
   nested within a comment
*/
.endliteral

.page 322 #import

Using the directive #import the contents of another file can be
textually included as in the C-language. The interpreter keeps track of
the imported files, so recursive imports or repeated imports do not form a
problem.

The filename (and not the full pathname) is used to determine if the file has
already been imported. Therefore "test.ama", "TEST.AMA" or "/amanda/test.ama"
are seen as different files although the names may actually refer to the same file.


Syntax: #import "<filename>"  (on a single line)


Example:

#import "a:/amanda/lib.ama"

.page 323 #synonym

Using the directive #synonym a name can be declared to be a synonym for
another name. The synonym is valid from the point of definition.

The synonym is textually replaced by its real name. Therefor it is possible
to make synonyms for operators and even for keywords like where.


Syntax: #synonym <synonym> <real name>  (on a single line)


Examples:

#synonym div /

#synonym mod %


With these definitions one may write [x | x <- [1..10]; x mod 2 = 0] to denote
[x | x <- [1..10]; x % 2 = 0]

.page 324 #operator

Using the directive #operator the associativity and the priority of an operator
can be defined. This directive is valid from the point of definition.

The priority should be a natural number from 1 (high priority) upto 7 (low
priority).

Even built in operators can be changed by this directive.


Syntax: #operator <associativity> <priority> <operator>  (on a single line)

associativity = l | r


Example:

#operator r 5 @

#operator l 6 ?


These definitions state that @ associates to the right with priority 5 and
that ? associates to the left with priority 6. So @ binds more strongly
than ?


The builtin operators have the following associativity and priority
.literal
operator  associativity  priority
  :         Right          1
  &         Left           1
  !         Left           2
  ^         Right          2
  *         Left           3
  /         Left           3
  //        Left           3
  %         Left           3
  ++        Right          4
  --        Left           4
  +         Left           4
  -         Left           4
  =         Right          5
  ~=        Left           5
  <         Left           5
  <=        Left           5
  >         Left           5
  >=        Left           5
  /\        Right          6
  \/        Right          7
.endliteral
The default associativity is Left.

The default priority is 1.


NB: the associativity of the relational operators (=, ~=, >, < etc) is
actually irrelevant, because an expression like 1 < 2 < 3 is not type correct.

.page 401 exit

exit


Commandline function used to leave Amanda.

.page 402 info

info


Commandline function which displays some information about memory size and
defined functions.

.page 403 load

load [char]


Commandline function used to load a file with function definitions.

.page 404 reload

reload


Commandline function used to reload a file with function definitions.

.page 405 time

time


Commandline function used to toggle timing mode.

In timing mode the duration of an evaluation is displayed.

.page 406 debug

debug :: * -> ** -> **


debug a b = b


As a side effect the first argument is displayed without being evaluated.


strict debug a b

will first evaluate a and then display it

.page 407 error

error :: [char] -> *


error message = ...


The message will be displayed and the evaluation is stopped.


Example:
.literal
hd [] = error "head of empty list"
hd (x:xs) = x
.endliteral

.page 411  ^

^ :: num -> num -> num


x ^ y = x raised to the power y

.page 412  *

* :: num -> num -> num


x * y = x multiplied by y

.page 413  /

/ :: num -> num -> num


x / y = integral division of x by y (x and y must be integers)

.page 414  //

// :: num -> num -> num


x // y = real division of x by y

.page 415  %

% :: num -> num -> num


x % y = the rest of the integral division of x by y (x and y must be integers)

.page 416  +

+ :: num -> num -> num


x + y = the sum of x and y

.page 417  -

- :: num -> num -> num


x - y = the difference of x and y


- :: num -> num


Depending on the context - can denote unary minus

(-x) = 0-x

.page 418  =

= :: * -> * -> bool


(x = y) = x is structurally equal to y

.page 419  ~=

~= :: * -> * -> bool


(x ~= y) = x is not structurally equal to y

.page 420  <

< :: * -> * -> bool


(x < y) = x is smaller than y (normally used for numbers)

List comparison is lexicographic.

.page 421  <=

<= :: * -> * -> bool


(x <= y) = x is smaller than or equal to y (normally used for numbers)

List comparison is lexicographic.

.page 422  >

> :: * -> * -> bool


(x > y) = x is larger than y (normally used for numbers)

List comparison is lexicographic.

.page 423  >=

>= :: * -> * -> bool


(x >= y) = x is larger than or equal to y (normally used for numbers)

List comparison is lexicographic.

.page 424  .

. :: (** -> ***) -> (* -> **) -> * -> ***


(f . g) x = f(g x)

.page 425  :

: :: * -> [*] -> [*]


x : [x1, x2 ... xN] = [x, x1, x2 ... xN]

.page 426  !

! :: [*] -> num -> *


[x0, x1 ...] ! n = xn (the (n+1)st element)

.page 427  ++

++ :: [*] -> [*] -> [*]


[x1, x2 ... xN] ++ [y1, y2 ... yM] = [x1, x2 ... xN, y1, y2 ... yM]

.page 428  --

-- :: [*] -> [*] -> [*]


xs -- ys = xs with repeatedly the first occurrence of an element of ys removed
.literal
(xs -- []) = xs
(xs -- (y:ys)) = remove y xs -- ys
where
  remove y [] = []
  remove y (x:xs) = xs            ,if x = y
                  = x:remove y xs ,otherwise
.endliteral

.page 429  /\

/\ :: bool -> bool -> bool


x /\ y = both x and y are True

.page 430  \/

\/ :: bool -> bool -> bool


x \/ y = at least one of x and y is True

.page 431  #

# :: [*] -> num


#[x1, x2 ... xn] = n (the number of elements)

.page 432  ~

~ :: bool -> bool


~ True = False

~ False = True

.page 433  &

& :: * -> * -> *


The operator & is used to update a record with information from another
record.


Example:


rectangle ::= { x :: num, y :: num, width :: num, height :: num }


translate (rect = { x = x, y = y }) dx dy = rect & { x = x + dx, y = y + dy }

.page 441 True

True :: bool

.page 442 False

False :: bool

.page 443 pi

pi :: num


pi = 3.1415...

.page 444 Nil

Nil :: [*]


Nil = []

.page 451 rep

rep :: * -> num -> [*]


rep x n = [x | k <- [1..n]]

.page 452 cjustify

cjustify :: num -> [char] -> [char]


cjustify n string = string centrally justified to occupy n positions

.page 453 ljustify

ljustify :: num -> [char] -> [char]


ljustify n string = string left justified to occupy n positions

.page 454 rjustify

rjustify :: num -> [char] -> [char]


rjustify n string = string right justified to occupy n positions

.page 455 lines

lines :: [char] -> [[char]]


lines "string1\nstring2\n....stringN" = ["string1", "string2" ... "stringN"]

.page 456 words

words :: [char] -> [[char]]


words string = list of words in string (spaces, newlines separate words)

.page 457 isspace

isspace :: char -> bool


isspace c = c is a space or newline

.page 458 isupper

isupper :: char -> bool


isupper c = c is a uppercase character

.page 459 islower

islower :: char -> bool


islower c = c is a lowercase character

.page 460 toupper

toupper :: char -> char


toupper c = c transformed to uppercase

.page 461 tolower

tolower :: char -> char


tolower c = c transformed to lowercase

.page 462 nodup

nodup :: [*] -> [*]


nodup removes duplicates from a list and keeps every first occurrence
.literal
nodup [] = []
nodup (x:xs) = x : nodup[y | y <- xs; y ~= x]
.endliteral

.page 463 unlines

unlines :: [[char]] -> [char]


unlines ["line1", "line2" ... "lineN"] = "line1\nline2\n...lineN\n"

.page 464 sort

sort :: [*] -> [*]
.literal
sort [] = []
sort (x:xs) = sort[y | y <- xs; y < x] ++ [x] ++ sort[y | y <- xs; y >= x]
.endliteral

.page 465 transpose

transpose :: [[*]] -> [[*]]
.literal
transpose
  [[x11, x12 ... x1N],
   [x21, x22 ... x2N]
   ...
   [xM1, xM2 ... xMN]]
= [[x11, x21 ... xM1],
   [x12, x22 ... xM2]
   ...
   [x1N, x2N ... xMN]]
.endliteral

.page 466 mergeSort

mergeSort :: [*] -> [*]


mergeSort = sort (but using the mergesort algorithm)

.page 467 merge

merge :: [*] -> [*] -> [*]


merge xs ys = the ordered merge of the ordered lists xs and ys

.page 468 zipwith

zipwith :: (* -> ** -> ***) -> [*] -> [**] -> [***]


zipwith (+) xs ys = [x + y | x, y <- xs, ys]

.page 471 and

and :: [bool] -> bool


and = foldr (/\) True

.page 472 abs

abs :: num -> num
.literal
abs x = x  ,if x >= 0
      = -x ,otherwise
.endliteral

.page 473 concat

concat :: [[*]] -> [*]


concat [x1, x2 ... xN] = x1 ++ x2 ++ ... xN

.page 474 drop

drop :: num -> [*] -> [*]


drop n xs = xs with the first n elements left out

.page 475 dropwhile

dropwhile :: (* -> bool) -> [*] -> [*]
.literal
dropwhile f [] = []
dropwhile f (x:xs) = dropwhile f xs ,if f x
                   = x:xs           ,otherwise
.endliteral

.page 476 empty

empty :: [*] -> bool
.literal
empty [] = True
empty (x:xs) = False
.endliteral

.page 477 filter

filter :: (* -> bool) -> [*] -> [*]


filter f xs = [x | x <- xs; f x]

.page 478 foldl

foldl :: (* -> ** -> *) -> * -> [**] -> *
.literal
foldl (+) z [] = z
foldl (+) z [x1, x2 ... xN] = ((z + x1) + x2) ... + xN
.endliteral
In pseudo notation:
.literal
foldl (+) z xs
begin
  for x <- xs do z := z + x;
  return z;
end
.endliteral

.page 479 foldl1

foldl1 :: (* -> * -> *) -> [*] -> *


foldl1 (+) [x1, x2 ... xN] = (x1 + x2) ... + xN


In pseudo notation:
.literal
foldl1 (+) (x:xs)
begin
  z := x;
  for x <- xs do z := z + x;
  return z;
end
.endliteral

.page 480 foldr

foldr :: (** -> * -> *) -> [**] -> *
.literal
foldr (+) z [] = z
foldr (+) z [x1, x2 ... xN] = x1 + (x2 ... + (xN + z))

foldr (+) z = f
where
  f [] = z
  f (x:xs) = x + f xs
.endliteral

.page 481 foldr1

foldr1 :: (* -> * -> *) -> [*] -> *


foldr1 (+) [x1, x2 ... xN] = x1 + (x2 ... + xN)

.page 482 fst

fst :: (*, **) -> *


fst(x, _) = x

.page 483 if

if :: bool -> * -> * -> *
.literal
if test x y = x ,if test
            = y ,otherwise
.endliteral

.page 484 iterate

iterate :: (* -> *) -> * -> [*]


iterate f x = [x, f x, f(f x), f(f(f x)) ...]

.page 485 hd

hd :: [*] -> *


hd (x:_) = x

.page 486 map

map :: (* -> **) -> [*] -> [**]


map f [x1, x2 ... xN] = [f x1, f x2 ... f xN]

.page 487 max

max :: [*] -> *


max xs = the largest element of xs

.page 488 max2

max2 :: * -> * -> *
.literal
max2 x y = x ,if x > y
         = y ,otherwise
.endliteral

.page 489 member

member :: [*] -> * -> bool
.literal
member xs x = True  ,if xs contains x
            = False ,otherwise
.endliteral

.page 490 min

min :: [*] -> *


min xs = the smallest element of xs

.page 491 min2

min2 :: * -> * -> *
.literal
min2 x y = x ,if x < y
         = y ,otherwise
.endliteral

.page 492 nat

nat :: num -> num -> [num]


nat k l = [k..l]

.page 493 nats

nats :: num -> [num]


nats k = [k..]

.page 494 neg

neg :: num -> num


neg x = -x

.page 495 or

or :: [bool] -> bool


or = foldr (\/) False

.page 496 prod

prod :: [num] -> num


prod = foldl (*) 1

.page 497 reverse

reverse :: [*] -> [*]


reverse [x1, x2 ... xN] = [xN ... x2, x1]

.page 498 scan

scan :: (* -> ** -> *) -> * -> [**] -> [*]


scan (+) z [] = [z]

scan (+) z [x1, x2 ... xN] = [z, z+x1, (z+x1)+x2 ... ((z+x1)+x2) ... +xN]

.page 499 seq

seq :: * -> ** -> **


seq x y = y

As a side effect x is evaluated

.page 500 snd

snd :: (*, **) -> **


snd(_, x) = x

.page 501 split

split :: num -> [*] -> ([*], [*])


split n xs = (take n xs, drop n xs)

.page 502 splitwhile

splitwhile :: (* -> bool) -> [*] -> ([*], [*])


splitwhile f xs = (takewhile f xs, dropwhile f xs)

.page 503 sum

sum :: [num] -> num


sum = foldl (+) 0

.page 504 strict

strict :: (* -> **) -> * -> **


strict f x = f x

As a side effect x is evaluated first

.page 505 take

take :: num -> [*] -> [*]


take n xs = the list of the first n elements of xs

.page 506 takewhile

takewhile :: (* -> bool) -> [*] -> [*]


takewhile f [] = []
.literal
takewhile f (x:xs) = x : takewhile f xs ,if f x
                   = []
.endliteral

.page 507 timedate

timedate :: (num, num, num, num, num, num)


timedate = (second, minute, hour, day /* [1..31] */, month /* [0..11] */, year)


timedate delivers the current time and date,  it is not referentially transparent

.page 508 tl

tl :: [*] -> [*]


tl (_:xs) = xs

.page 509 until

until :: (* -> bool) -> (* -> *) -> * -> *
.literal
until test f x = x                  ,if test x
               = until test f (f x) ,otherwise
.endliteral
Alternatively:

until test f = hd . dropwhile (~ . test) . iterate f

.page 510 zip

zip :: ([*], [**]) -> [(*, **)]


zip(xs, ys) = [(x, y) | x, y <- xs, ys]

.page 511 zip2

zip2 :: [*] -> [**] -> [(*, **)]


zip2 xs ys = [(x, y) | x, y <- xs, ys]

.page 512 zip3

zip3 :: [*] -> [**] -> [***] -> [(*, **, ***)]


zip3 xs ys zs = [(x, y, z) | x, y, z <- xs, ys, zs]

.page 521 round

round :: num -> num


round x = x rounded to the nearest integer

.page 522 trunc

trunc :: num -> num


trunc x = x truncated to the nearest integer (so its absolute value decreases)

.page 523 decode

decode :: num -> char


decode n = character with ascii value n (n integer, 0 <= n < 256)

.page 524 code

code :: char -> num


code c = ascii value of c

.page 525 random

random :: num -> num


random n = a random number r with 0 <= r < n (n integer, n > 0)


random should be used with care, because it is not referentially transparent.


Example:

[r | k <- [1..100]; r := random 10] ~= [r | r := random 10; k <- [1..100]]

.page 526 cos

cos :: num -> num

.page 527 sin

sin :: num -> num

.page 528 exp

exp :: num -> num


exp x = e ^ x

.page 529 log

log :: num -> num


log x = natural logarithm of x

.page 530 sqrt

sqrt :: num -> num


sqrt x = x ^ 0.5

.page 531 atan

atan :: num -> num

.page 532 itoa

itoa :: num -> [char]


itoa n = string representation of the integer n

.page 533 atoi

atoi :: [char] -> num


atoi s = value of the first integer denoted in s or 0 if none

.page 534 ftoa

ftoa :: num -> [char]


ftoa n = string representation of the number n

.page 535 atof

atof :: [char] -> num


atof s = value of the first number denoted in s or 0 if none

.page 541 fread

fread :: [char] -> [char]


fread fileName = list of the characters in the file


fread should be used with care, because it is not referentially transparent.


Example:

lineCount = # . lines . fread


fread reads the contents of the file as a list of characters, lines breaks
this list in a list of lines and # counts the number of lines.

.page 542 fwrite

fwrite :: [char] -> [char] ->  bool
.literal
fwrite fileName string = True  ,if the string is written to the file
                       = False ,otherwise
.endliteral
fwrite should be used with care, because it is not referentially transparent.

.page 543 fappend

fappend :: [char] -> [char] ->  bool
.literal
fappend fileName string = True  ,if the string is appended to the file
                        = False ,otherwise
.endliteral
fappend should be used with care, because it is not referentially transparent.
