          Mocca
          ===========

        1 Introduction

          Mocca is a java-preprocessor. 
          It adds abbreviations, data classes, comprehensions, proc's and macro's to java.
          The resulting language has a pascal flavour with elements as (variant) records,
          nesting of procedures and procedure types.
          The modern datatype Seq and the comprehensions give it a python flavour.
          The macro's and names like struct and union give it a c flavour.
          
          Mocca is statement based. It rewrites one or more lines of mocca to many lines
          of java. 
          This makes the use of comprehensions sometimes clumsy, because they are actually
          expressions and java lacks the algol68 way of turning statements into expressions.
          
          Mocca is made by Dick Bruin in order to make java programming more abstract.
          And to make better use of java's nested/inner classes. 
          Mocca makes it easy to define data classes.
          Mocca makes it easy to split a procedure in small subprocedures. 
          Comprehensions may be seen as constructors of collections. They separate the
          data retrieval from the data usage (after the construction the collection is not
          altered but only inspected).
          
          
      1.1 Abbreviations
          
    1.1.1 Seq
          
          Seq is just a shorthand for ArrayList.
          It adds a constructor which can take zero or more elements to iniatialise the seq with.
      
    1.1.2 Var statement
      
          A var statement is an abbreviation which avoids the duplication of the typename.
          Examples:
            var eleven = new Integer(11);
            var list=new Seq<Integer>();
          
          They expand to
          // mocca:     var eleven = new Integer(11);
              Integer eleven = new Integer(11);
          // mocca:     var list=new Seq<Integer>();
              Seq<Integer> list=new Seq<Integer>();
              
          
      1.2 Data classes
      
    1.2.1 Struct
      
          A struct is a simple data class.
          Example:
          
            public struct Coord(double x, double y);
          
          It expands to:
          
            // mocca: public struct Coord(double x, double y);
            public class Coord
            {
              public double x;
              public double y;

              public Coord(double x, double y)
              {
                this.x = x;
                this.y = y;
              }

              public boolean equals(Object obj)
              {
                if(!(obj instanceof Coord)) return false;
                Coord other = (Coord)obj;
                return other.x == x && other.y == y;
              }

              public String toString()
              {
                return "Coord(" + x + ", " + y + ")";
              }
            }
          
          
    1.2.2 Union
      
          A union is a collection of structs which is collapsed to a single data class.
          It resembles an algebraic data type of functional programming.
          Example:
          
            public union Graphic
            {
              text(Color c, Coord p, String t);
              polyline(Color c, Seq<Coord> ps);
              polygon(Color c, Seq<Coord> ps);
              rectangle(Color c, Coord p1, Coord p2);
              ellipse(Color c, Coord p1, Coord p2);
              disc(Color c, Coord p1, Coord p2);
            }
          
          Typical usage:
          
            Graphic g = Graphic.text(Color.blue, new Coord1(0.0, 0.0), "bla");
            
            switch(g.tag)
            {
              case text:
                System.out.println(g.t);
                ..
                break;
              ..
            }
          
          It expands to:
          
            // mocca: public union Graphic
            // mocca: {
            // mocca:   text(Color c, Coord p, String t);
            // mocca:   polyline(Color c, Seq<Coord> ps);
            // mocca:   polygon(Color c, Seq<Coord> ps);
            // mocca:   rectangle(Color c, Coord p1, Coord p2);
            // mocca:   ellipse(Color c, Coord p1, Coord p2);
            // mocca:   disc(Color c, Coord p1, Coord p2);
            // mocca: }
            public class Graphic
            {
              public static enum Tag { text, polyline, polygon, rectangle, ellipse, disc }

              public Tag tag;
              public Color c;
              public Coord p;
              public String t;
              public Seq<Coord> ps;
              public Coord p1;
              public Coord p2;

              public static Graphic text(Color c, Coord p, String t)
              {
                Graphic result = new Graphic();
                result.tag = Tag.text;
                result.c = c;
                result.p = p;
                result.t = t;
                return result;
              }
              
              ...

              public boolean equals(Object obj)
              {
                if(!(obj instanceof Graphic)) return false;
                Graphic other = (Graphic)obj;
                if(other.tag != tag) return false;
                switch(tag)
                {
                  case text:
                    return other.c.equals(c) && other.p.equals(p) && other.t.equals(t);
                  ...
                }
                return super.equals(obj);
              }

              public String toString()
              {
                switch(tag)
                {
                  case text:
                    return "Graphic.text(" + c + ", " + p + ", " + t + ")";
                  ...
                }
                return super.toString();
              }
            }


      1.3 Comprehensions
      
    1.3.1 Listcomprehension
      
          Examples:
            var al = Seq<Integer>[9, 8];
            var al = Seq<Integer>[9, 8 range(k, 0, 5)];
            var al = Seq<Integer>[9, 8 range(k, 0, 5) if(k % (2) == 0)];
            var al = Seq<Integer>[9, 8 for(int k=0; k<5; k++) if(k % (2) == 0)];
            var xy = Seq<Integer>[x+y range(x, 0, 10) range(y, 0, x)];
            xx = Seq<Integer>[y range(x, 0, 10) let(int y = x*x)];
            
            return HashSet<Integer>
                     [y range(x, 0, 10) 
                        let(var ys = Seq<Integer>[x, x*x])
                        for(Integer y : ys)
                     ];
            
          Listcomprehensions can be used in var statements, in assignments and in return statements,
          but can not be nested inside method calls.
          This is not a severe restriction because a listcomprehension typically is used as a
          constructor of an (immutable) arraylist.
          
          A var statement introduces a new variable.
          
          The type of the resulting Collection (Seq, ArryList, HashSet ..) should be provided.
          NB: collection comprehension would be a better name. 
          The expanded code only uses a default constructor and the add method.
          
          range(var, low, high) is an abreviation of for(int var=low; var<high; var++).
          let(...) can be used for calculations inside a listcomprehension.
          until(condition) stops all generation loops.
          
          Stopping only 1 loop can be achieved by let(if(...) break)
          Nested listcomprehensions are possible through let(var ... = ...)
          
          Most rewritings are straightforward like:
            // mocca:             var xy = Seq<Integer>[x+y range(x, 0, 10) range(y, 0, x)];
                        Seq<Integer> xy = new Seq<Integer>();
                        for(int x=0; x<10; x++)
                        for(int y=0; y<x; y++)
                          xy.add(x+y);
                    
          An example to demonstrate until:
            // mocca:             var s = sum<int>[x+y range(x, 1, 10) range(y, 1, 10) until(y>x)];
                        int s = 0;
                        { _block_1: {
                          for(int x=1; x<10; x++)
                          for(int y=1; y<10; y++)
                          {
                            if(y>x) break _block_1;
                              s += x+y;
                        }}}
                        
           The resulting value = 2.


    1.3.2 Aggregates
      
          Besides Collections (Seq, ArryList, HashSet ..) the same syntax can be used to calculate aggregate
          values. This resembles the foldl of functional programming.
      
          Examples:
            s += max<int>[x+y range(x, 0, 10) range(y, 0, 10)];
            return or<boolean>[x > 3 range(x, 0, 10)];
            
          The numeric aggregates are "sum, count, min, max" for the types "int, float, double".
          The boolean aggregates are "or, and".

          They expand to
            // mocca:             s += max<int>[x+y range(x, 0, 10) range(y, 0, 10)];
                        { int _mocca_12 = -1000000;
                          for(int x=0; x<10; x++)
                          for(int y=0; y<10; y++)
                            { int _val_12 = x+y; if(_val_12 > _mocca_12) _mocca_12 = _val_12; }
                          s += _mocca_12;
                        }
                          
            // mocca:             return or<boolean>[x > 3 range(x, 0, 10)];
                       { boolean _mocca_1 = false;
                         { _block_1: {
                           for(int x=0; x<10; x++)
                             if(x > 3) { _mocca_1 = true; break _block_1; }
                         }}
                         return _mocca_1;
                       }
      
    1.3.2 Fold
          
          The general form of a comprehension is a fold.
          Example:
            som -= fold<int>[x = 0, x += k range(k, 0, 11) if(k<10)];
            
          Here x is the accumulating variable, which starts from 0 and is updated by x += k for each k.
          It expands to:
            // mocca:     som -= fold<int>[x = 0, x += k range(k, 0, 11) if(k<10)];
                { int x = 0;
                  for(int k=0; k<11; k++)
                  if(k<10)
                    x += k;
                  som -= x ;
                }          
            
          Example:
            var sumstrs = fold<String>[w = "", w = str, w += " " + str for(String str : strs)];
            
          Now the accululating variable is w, which starts with "" and is updated 
          the first time by w = str and the next times by w += " " + str.
          It expands to:
            // mocca:     var sumstrs = fold<String>[w = "", w = str, w += " " + str for(String str : strs)];
                String sumstrs;
                { String w = "";
                  int _count_24 = 0;
                  for(String str : strs)
                    switch(++_count_24) {
                    case 1: w = str; break;
                    default: w += " " + str; break;
                  }
                  sumstrs = w ;
                }
          
          In functional programming style the examples are:
            foldl (+) 0 [k | k <- [0..11-1]; k < 10]
            foldl1 (x->y->x++" "++y) strs
          
          A function f is a fold if there is an operator op so that:
            f (a ++ b) = (f a) op (f b)
          So (f []) must be the neutral element. 
          The operator op must be associative.
          The mapping (f [x]) must be known.
          
          Illustrative is the count aggregate.
          Its operator is + (int).
          Its neutral element is 0
          Its mapping is _ -> 1
          
          Most folds using the identity as mapping.
          
          A fold can be evaluated in more than one way and even in parallel.
          Mocca generates a left to right evaluation order.
          f [k1, k2, .. kN] = ((f [] op f [k1]) op f [k2]) op ...    N >= 0
          f [k1, k2, .. kN] = ((f [k1] op f [k2]) op f [k3]) op ...  N >= 1
          The first example codes: x = f [], x = x op f [kN]
          The second example codes: x = f [], x = f [k1], x = x op f [kN]
          
          It seems unlikely that there are cases where more than 2 update functions are needed.
          It is up to the programmer to ensure that a fold is based on an associative operator.
      

      1.4 Proc's
          
          A proc is a public method with some added features like local definitions, default parameters and 
          inout parameters.
          
    1.4.1 Local definitions
    
          Where clauses are well known from functional programming and from the pascal programming language.
          In mocca a where clause is introduced using the key words proc and where.

          Example:          
            proc int f(int x)  
            {
              return g(3) + z;
            }
            where  
            {
              int z = 5;
              
              int g(int y)  
              {
                return x + y;
              }
            }
          
          Here f is a function with parameter x and local definitions z and g.
          The scope of x, z and g is all execution blocks.
          The local function g has parameter y.
          The scope of y is the execution block of g.
          
          A proc is implemented using a (nested) class with the same name.         
          The example expands to:
            // mocca
            public int f(int x)
            {
              return new f().call(x);
            }
            
            // mocca
            public class f
            {
              int x;
            
              public int call(int _arg_0)
              {
                x = _arg_0;
                return g(3) + z;
              }
            
              int z = 5;
              
              int g(int y)  
              {
                return x + y;
              }
            }
          
          This has some performance overhead, especially the loading of the nested class takes some time.
          
          It makes function parameters and local definitions accessible to anonymous inner classes.
          Example:
          
            proc void main(String[] args)
            {
              SwingUtilities.invokeLater(new Runnable(){public void run(){new Layman(args);}});
            }
          
          The parameter args now needs not be final, but of course static is not allowed.
          
          More importantly it makes pascal style nested functions possible.
          
  
    1.4.2 Default parameters
    
          Using the syntax (type arg = defaultvalue) default parameters are made possible for proc's.
    
          Example:
            proc int nfib(int n = 0)
            {
              return n <= 1 ? 1 : 1 + nfib(n-1) + nfib(n-2);
            }
            
            System.out.println("nfib0 = " + nfib());
            System.out.println("nfib1 = " + nfib(1));
      
    1.4.3 Var parameters
    
          Using the syntax (var variable) inout parameters can be specified for certain types
          of calls of proc's.
          
          Example:
            proc void nfib2(int n, var int res)
            {
              if(n <= 1)
                res = 1;
              else
              {
                int res1 = 0;
                int res2 = 0;
                call nfib2(n-1, var res1);
                call nfib2(n-2, var res2);
                res = 1 + res1 + res2;
              }
            
            int nn = 0;
            call nfib2(35, var nn);
            System.out.println("nfib2 = " + nn);
            
          The call expands to:
            // mocca:     call nfib2(35, var nn);
                {
                  nfib2 _proc_ = new nfib2();
                  _proc_.call(35, nn);
                  nn = _proc_.getArg1();
                }
          
          For var parameters extra access functions getArg.. are generated.
          
    1.4.4 Proc types
    
          Proc types can be defined.
          Example (definition):          
            proc int IntProc(int);
            proc int IntValueProc();
            
          Example (usage):          
            proc int nfib(int n = 0) implements IntProc, IntValueProc
            {
              return n <= 1 ? 1 : 1 + nfib(n-1) + nfib(n-2);
            }
            
          A proc type maps to a java interface:
            // mocca:   proc int IntProc(int);
              public interface IntProc
              {
                int call(int _arg_0);
              }
            
          And can be used like this:
            IntProc ip = new nfib();
            System.out.println( ip.call(7) );
            
            ip = new IntProc(){ public int call(int x) { return x + 1; }};
            System.out.println(ip.call(7));
    
            IntValueProc vp = new nfib();
            System.out.println( vp.call() );   
          
          The first and last one demonstrate the effect of the default parameter.
          The middle one demonstrates java's verbose lambda's.
          
          NB: also var can be specified for a parameter.
          Example:
            proc void VarIntProc(var int);
      
            
      1.5 Macro's
          
          The key word let introduces macro definitions. 
          A macro may reference other macro's.
          
          Examples:
            let range(v, l, h) := for(int v=l; v<h; v++)
            let text := Seq<String>
          
          A macro must be defined on one line.
          Macro's are global definitions and are best placed at the beginning of the file.
          
          A macro is a textual substitution. 
          NB: for each line up to 10 of these substitutions are performed.
          
          Predefined macro's:
            let Seq<int>       := Seq<Integer>
            let Seq<float>     := Seq<Float>
            let Seq<double>    := Seq<Double>
            let Seq<boolean>   := Seq<Boolean>
            let Seq<char>      := Seq<Character>
            let range(v, l, h) := for(int v=l; v<h; v++)
            
          This makes it possible to write:
            var numbers = new Seq<int>(1, 2, 3);
          
          Parameters of macro's must be written inside parentheses. In case the macro
          has no parameters no parentheses are needed.
          In that way Seq<int>(1, 2, 3) is correctly rewritten to Seq<integer>(1, 2, 3)
          
          
        2 Restrictions
          
          Being a preprocessor mocca does not do any syntax checks. It assumes correct syntax, 
          scans the source text for information and generates java code based on the scan.
          Also mocca does not do any semantic checks. Therefore it can be cumbersome to
          correct type errors. Especially because one line of mocca may be expanded to many
          lines of java.
          Unions use the technique of collapsing. Thus fields of different structs with the
          same name are implemented by a single field in the java class. This can only work
          well if the types are also the same.
          
          The heading of a var-statement (var varname = new type) should be put on a single line.
          The constructor details may be put on following lines.
          
          A struct should be placed on a single line. No other statements or comments should
          be put on that line. 
          Every field of a struct consists of a typename and a fieldname (only one).
          
          A union should be put on multiple lines. Every element (heading and structs) should be put
          on a single line. No other statements or comments should be put on such lines.
          
          A listcomprehension may span multiple lines. The heading (var varname = typename) should
          be put on a single line. Again it is best not to put comments inside a listcomprehension.
          The local names inside the generators of a listcomprehension are in the same namespace as
          the variable it is assigned to. So the generators should have distinct names which are
          different from the name of the variable.
          
          For proc's and where's it is best to put them on a single line. The closing brace of a 
          block should be put on a single line. The opening brace can most of the times be
          put at the end of the line containing proc or where.
          The arguments of a proc may not be of variable length, because that conflicts with
          the possiblity of being var parameters.
          
          NB: mocca essentially does a repeated rewrite of groups of contiguous lines
          into new groups of lines. This makes nesting possible, but the downside are the
          restrictions on the use of comments etc.
          
          NB: types in structs, unions, listcomprehensions and where clauses should be written 
          without intermediate white space. 
          
          Examples:
            private struct Cell(int puzzelVal, int solutionVal, boolean[] possible, Seq<Group> groups);
            private struct Group(boolean[] possible, Seq<Cell> cells);
            private struct Candidate(Cell cell, int cand);
            private struct Candidates(Cell cell1, int cand1, Cell cell2, int cand2);
          
            cells  = Seq<Cell>[new Cell(0, 0, new boolean[10], new Seq<Group>())  range(k, 0, 81)];    
            groups = Seq<Group>[new Group(new boolean[10], new Seq<Cell>()) range(k, 0, 36)];  
          
          Java does allow things like:
            boolean []possible
            Seq <Cell>
            
          Mocca only understands:
            boolean[] possible
            Seq<Cell>
          
          In mocca the programmer has to explicitly state that a proc implements a proctype.
          No duck typing allowed here. 
          This is limitation of the prepocessor. Structural typing is of course perfectly suited
          for functions.
          A proctype being a java interface and therefore static can not be defined in an inner class.
          This is a java limitation, that is somewhat surprising if you acknowledge the fact
          that java inner classes make deeply nested closures possible. 
          A thing that is lacking in most pascal or c implementations.
          
